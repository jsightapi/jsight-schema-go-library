// Autogenerated code!
// DO NOT EDIT!
//
// Generated by OrderedMap generator from the internal/cmd/generator command.

package schema

import (
	"bytes"
	"context"
	"encoding/json"

	"j/schema/notations/jschema/internal/schema/constraint"
)

// Set sets a value with specified key.
func (m *Constraints) Set(k constraint.Type, v constraint.Constraint) {
	m.mx.Lock()
	defer m.mx.Unlock()

	if m.data == nil {
		m.data = map[constraint.Type]constraint.Constraint{}
	}
	if !m.has(k) {
		m.order = append(m.order, k)
	}
	m.data[k] = v
}

// Update updates a value with specified key.
func (m *Constraints) Update(k constraint.Type, fn func(v constraint.Constraint) constraint.Constraint) {
	m.mx.Lock()
	defer m.mx.Unlock()

	if !m.has(k) {
		// Prevent from possible nil pointer dereference if map value type is a
		// pointer.
		return
	}

	m.data[k] = fn(m.data[k])
}

// GetValue gets a value by key.
func (m *Constraints) GetValue(k constraint.Type) constraint.Constraint {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return m.data[k]
}

// Get gets a value by key.
func (m *Constraints) Get(k constraint.Type) (constraint.Constraint, bool) {
	m.mx.RLock()
	defer m.mx.RUnlock()

	v, ok := m.data[k]
	return v, ok
}

// Has checks that specified key is set.
func (m *Constraints) Has(k constraint.Type) bool {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return m.has(k)
}

func (m *Constraints) has(k constraint.Type) bool {
	_, ok := m.data[k]
	return ok
}

// Len returns count of values.
func (m *Constraints) Len() int {
	m.mx.RLock()
	defer m.mx.RUnlock()

	return len(m.data)
}

func (m *Constraints) Delete(k constraint.Type) {
	m.mx.Lock()
	defer m.mx.Unlock()

	m.delete(k)
}

func (m *Constraints) delete(k constraint.Type) {
	var kk constraint.Type
	i := -1

	for i, kk = range m.order {
		if kk == k {
			break
		}
	}

	delete(m.data, k)
	if i != -1 {
		m.order = append(m.order[:i], m.order[i+1:]...)
	}
}

// Filter iterates and changes values in the map.
func (m *Constraints) Filter(fn filterConstraintsFunc) {
	m.mx.Lock()
	defer m.mx.Unlock()

	for _, k := range m.order {
		if !fn(k, m.data[k]) {
			m.delete(k)
		}
	}
}

type filterConstraintsFunc = func(k constraint.Type, v constraint.Constraint) bool

// Iterate acts the same as IterateContext but with background context.
func (m *Constraints) Iterate() <-chan ConstraintsItem {
	return m.IterateContext(context.Background())
}

// IterateContext iterates over map key/values.
// Will block in case of slow consumer.
// Context should be canceled in order to avoid infinity lock.
// Use Constraints.Map when you have to update value.
func (m *Constraints) IterateContext(ctx context.Context) <-chan ConstraintsItem {
	ch := make(chan ConstraintsItem)
	go func() {
		m.mx.RLock()
		defer m.mx.RUnlock()

		for _, k := range m.order {
			select {
			case <-ctx.Done():
				break
			case ch <- ConstraintsItem{
				Key:   k,
				Value: m.data[k],
			}:
			}
		}
		close(ch)
	}()
	return ch
}

// ConstraintsItem represent single data from the Constraints.
type ConstraintsItem struct {
	Key   constraint.Type
	Value constraint.Constraint
}

var _ json.Marshaler = &Constraints{}

func (m *Constraints) MarshalJSON() ([]byte, error) {
	m.mx.RLock()
	defer m.mx.RUnlock()

	var buf bytes.Buffer
	buf.WriteRune('{')

	for i, k := range m.order {
		if i != 0 {
			buf.WriteRune(',')
		}

		// marshal key
		key, err := json.Marshal(k)
		if err != nil {
			return nil, err
		}
		buf.Write(key)
		buf.WriteRune(':')

		// marshal value
		val, err := json.Marshal(m.data[k])
		if err != nil {
			return nil, err
		}
		buf.Write(val)
	}

	buf.WriteRune('}')
	return buf.Bytes(), nil
}
